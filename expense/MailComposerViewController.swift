//
//  MailComposerViewController.swift
//  InVoice
//
//  Created by Richard Marktl on 30.01.18.
//  Copyright Â© 2018 meisterwork GmbH. All rights reserved.
//

import UIKit
import Foundation
import RxSwift
import Horreum
import TURecipientBar
import ContactsUI
import FirebaseMessaging
import Crashlytics
import Intents



/// The MailComposerViewController takes the job and sends the mail through the invoice bot api
/// the pdf is not send as mail directly, it is uploaded to the server and stored there to be
/// accessed through a link generated by the api.
class MailComposerViewController: UIViewController, Resetable {
    // the address line view element
    @IBOutlet weak var bar: TURecipientsBar!
    private var controller: TURecipientsDisplayController!
    private var model: MailClientsModel!

    private var recipientsSet = Set<String>()
    private let regex = try? NSRegularExpression(pattern: "..+@..+", options: [])
    fileprivate let registerPushNotificationModel = RegisterNotificationModel()

    // the preview view elements
    @IBOutlet weak var previewView: UIView!
    @IBOutlet weak var numberLabel: UILabel!
    @IBOutlet weak var totalLabel: UILabel!
    @IBOutlet weak var messageTextView: UITextView!
    @IBOutlet weak var addressLabel: UILabel!
    @IBOutlet weak var previewButton: ActionButton!

    // helper members
    private var bag: DisposeBag = DisposeBag()
    
    
    public var job: Job!
    public var pdf: RenderedPDF!

    override func viewDidLoad() {
        super.viewDidLoad()
        controller = TURecipientsDisplayController(recipientsBar: bar, contentsController: self)
        controller.delegate = self

        if let topItem = navigationController?.navigationBar.topItem {
            topItem.backBarButtonItem = UIBarButtonItem(title: "", style: UIBarButtonItemStyle.plain, target: nil, action: nil)
        }
        
        configureBar()
        configureNavigationItem()  // configure the navigation bar item

        model = MailClientsModel(searchObservable: bar.textField.rx.text.filterNil(), with: Horreum.instance!.mainContext)
        model.sectionsObservable.subscribe(onNext: { [unowned self] (_) in
            self.controller.searchResultsTableView?.reloadData()
        }).disposed(by: bag)

        // configure the keyboard accessory for the x
        let keyboardAccessoryView = MailKeyboardAccessory(frame: CGRect(x: 0, y: 0, width: 320, height: 44))
        messageTextView.inputAccessoryView = keyboardAccessoryView
        keyboardAccessoryView.hideKeyboardObservable.subscribe(onNext: { [unowned self] (_) in // Hide Keyboard Button
            self.messageTextView.resignFirstResponder()
        }).disposed(by: bag)

        add(client: job.client) // add the first recipient, if no email available will not be set.
        
        let number = job.number ?? ""
        let jobString = job.localizedTypeKey.localizeFromCurrentSelectedBundle() + ": " + number
        let jobType = job.localizedTypeInMiddleOfSentenceKey.localizeFromCurrentSelectedBundle()
        let name = Account.current().name ?? R.string.localizable.noName()
        let address = Account.current().address ?? ""
        
        previewButton.title = R.string.localizable.showPreview()
        messageTextView.text = R.string.localizable.mailMessageText.key.localizeFromCurrentSelectedBundle(job.clientName ?? "", jobType, number, name)
        numberLabel.text = jobString
        addressLabel.text = name + "\n" + address
        totalLabel.text = R.string.localizable.mailTotal.key.localizeFromCurrentSelectedBundle(job.total?.asCurrency(currencyCode: job.currency) ?? "0")
        
        previewButton.tapObservable.subscribe(onNext: { [unowned self] () in
            guard let ctr: GeneratedPreviewController = R.storyboard.preview.instantiateInitialViewController() else {
                return
            }
            
            ctr.job = self.job
            ctr.pdf = self.pdf
            ctr.hideSendButton = true
            self.navigationController?.pushViewController(ctr, animated: true)
        }).disposed(by: bag)
        
        logger.verbose("[MAIL] show the job mail composer")
    }
    
    override func viewDidAppear(_ animated: Bool) {
        super.viewDidAppear(animated)
        if recipients().count == 0 {
            bar.textField.becomeFirstResponder()
        }
    }
    
    private func add(client: Client?) {
        if let client = client, let email = client.email {
            add(email: email, name: client.name)
        }
    }
    
    private func add(email: String, name: String?) {
        if email.isEmpty == false && recipientsSet.contains(email) == false {
            recipientsSet.insert(email)
            bar.addRecipient(MailRecipient(email: email, name: name))
            recipientsUpdated()
        }
    }
    
    private func recipientsUpdated() {
        let enable: Bool = (bar.recipients.count > 0)
        navigationItem.rightBarButtonItem?.isEnabled = enable
        bar.displayMode = (enable) ? .expanded : .automatic
    }
    
    private func recipients() -> [[String: String]] {
        var emails: [[String: String]] = []
        for recipient in self.bar.recipients {
            if let recipient = recipient as? MailRecipient {
                var email: [String: String] = ["email": recipient.email]
                
                if let name = recipient.name {
                    email["name"] = name
                }
                emails.append(email)
            }
        }
        return emails
    }
    
    private func recipientMails() -> [String] {
        var emails: [String] = []
        for recipient in self.bar.recipients {
            if let recipient = recipient as? MailRecipient {
                emails.append(recipient.email)
            }
        }
        return emails
    }
    
    private func send() {
        _ = self.shouldReset(showDialog: job.willResetSignature).take(1).filterTrue().subscribe(onNext: { [unowned self] (_) in
            _ = self.checkIfPushNotificationsIsEnabled().subscribe(onNext: { [unowned self] (_) in
                self.send(pdf: self.pdf)
            })
        })
    }
    
    private func send(pdf: RenderedPDF) {
        let job: Job! = self.job  // the controller should not be referenced in any of the called blocks
        
        let mailParameters: MailParameter = (data: pdf.data, text: messageTextView.text, recipients: recipients())
        let changedOrders = job.changedOrders
        let changedAttachments = job.changedAttachements
        let changedPayments = job.changedPayments
        
        // store this parameters to restore the states and recpients if necessary
        let oldRecipients = job.recipientsTyped
        let oldTimestamp = job.sentTimestamp
        let oldState = job.state
        
        // save the job immediately and set it back in the error case.
        job.markAsSend(recipientMails())
        
        // Upload the client if the client was created or changed during the creation of the job.
        _ = ClientUploader.upload(for: job).flatMap({ (job: Job) -> Observable<Job> in
            return JobUploader.upload(
                    job,
                    sendTo: mailParameters,
                    changedOrders: changedOrders,
                    changedAttachments: changedAttachments,
                    changedPayments: changedPayments
                )
            })
            .take(1)
            .subscribe(onNext: { (job) in
                logger.verbose("[MAIL] Did send job: \(job.number ?? "")")
                Analytics.actionSendEmailWithTracking.logEvent()
              
                if #available(iOS 12, *) {
                    if let intent = job.createSendIntent() {
                        let interaction = INInteraction(intent: intent, response: nil)
                        logger.debug("Donating intent: \(intent)")
                        interaction.donate(completion: { (error) in
                            guard let error = error else {return}
                            logger.error(error)
                            Crashlytics.sharedInstance().recordError(error)
                        })
                    }
                }
                
            }, onError: {(error) in
                logger.error("[MAIL] Job mail request failed: \(error)")
                
                // restore the old valuse from before the sending occured.
                job.sentTimestamp = oldTimestamp
                job.state = oldState
                
                oldRecipients.forEach({ (recipient) in
                    job?.addToRecipients(recipient)
                })
                
                Analytics.actionSendEmailWithTrackingFailed.logEvent()
                // get the top most view controller and then show an error message
                ErrorPresentable.show(error: error)
                Crashlytics.sharedInstance().recordError(error)
            }, onCompleted:{ () in
                try? job.managedObjectContext?.save()
            })
        
        self.dismiss(animated: true, completion: nil)
    }
    
    private func showContacts() {
        let contactController = CNContactPickerViewController()
        contactController.predicateForEnablingContact = NSPredicate(format: "emailAddresses.@count > 0")
        bar.text = ""
        
        let cancel = contactController.rx.didCancel
        _ = contactController.rx.didSelect.take(1).takeUntil(cancel).subscribe(onNext: { [unowned self] (contact) in
            if let email = contact.emailAddresses.first?.value as String? {
                let name = contact.givenName + " " + contact.familyName
                self.add(email: email, name: name)
            }
            self.dismiss(animated: true, completion: nil)
        })
        
        self.present(contactController, animated: true)
    }
    
    private func configureNavigationItem() {
        let font = FiraSans.medium.font(16)
        navigationController?.navigationBar.shadowImage = UIImage()
        navigationItem.title = R.string.localizable.mailSendNumber(job.number ?? "")

        navigationItem.rightBarButtonItem = UIBarButtonItem(title: R.string.localizable.mailSend(), style: .done, target: nil, action: nil)
        navigationItem.rightBarButtonItem?.setTitleTextAttributes([NSAttributedStringKey.font: font], for: .normal)
        navigationItem.rightBarButtonItem?.setTitleTextAttributes([NSAttributedStringKey.font: font], for: .disabled)
        navigationItem.rightBarButtonItem?.isEnabled = false // will be enabled through the add methods
        navigationItem.rightBarButtonItem?.rx.tap.subscribe(onNext: { [unowned self] (_) in
            self.send()
        }).disposed(by: bag)
    }

    private func configureBar() {
        bar.backgroundColor =  UIColor.main
        bar.lineView.backgroundColor =  UIColor.main
        bar.displayMode = .automatic
        bar.showsAddButton = true
        bar.toLabel.text = R.string.localizable.mailTo()
        bar.toLabel.textColor = .white
        bar.toLabel.font = FiraSans.regular.font(17)
        bar.textField.font = FiraSans.regular.font(17)
        bar.textField.textColor = .white
        bar.textField.tintColor = .white
        bar.textField.returnKeyType = .done
        bar.textField.keyboardType = .emailAddress
        bar.placeholder = R.string.localizable.mailPlaceHolder()
        bar.placeholderTextAttributes = [
            NSAttributedStringKey.font.rawValue: FiraSans.regular.font(17),
            NSAttributedStringKey.foregroundColor.rawValue: UIColor(white: 1.0, alpha: 0.6)
        ]
        
        bar.addButton.tintColor = .white
        bar.addButton.rx.tap.subscribe(onNext: {  [unowned self] (_) in
            self.showContacts()
        }).disposed(by: bag)
        TURecipientButton.appearance().tintColor = .white

        let attributes: [String: Any] = [
            NSAttributedStringKey.font.rawValue: FiraSans.regular.font(15),
            NSAttributedStringKey.foregroundColor.rawValue: UIColor.white
        ]
        let highlightedAttributes: [String: Any] = [
            NSAttributedStringKey.font.rawValue: FiraSans.regular.font(15),
            NSAttributedStringKey.foregroundColor.rawValue: UIColor.main
        ]
        bar.setRecipientTitleTextAttributes(attributes, for: .normal)
        bar.setRecipientTitleTextAttributes(highlightedAttributes, for: .highlighted)
        bar.setRecipientTitleTextAttributes(highlightedAttributes, for: .selected)
    }
}

// MARK: - TURecipientsDisplayDelegate
extension MailComposerViewController: TURecipientsDisplayDelegate {
    func recipientsDisplayController(_ controller: TURecipientsDisplayController, didLoadSearchResultsTableView tableView: UITableView) {
        tableView.register(R.nib.clientCell(), forCellReuseIdentifier: R.reuseIdentifier.mailInvoiceClientCell.identifier)
    }
    
    func recipientsDisplayController(_ controller: TURecipientsDisplayController, displaySearchResultsTableView tableView: UITableView) {
        let options = NSLayoutFormatOptions(rawValue: 0)
        let views = ["tableView": tableView]
        previewView.addSubview(tableView)
        previewView.addConstraints(NSLayoutConstraint.constraints(withVisualFormat: "H:|[tableView]|", options: options, metrics: nil, views: views))
        previewView.addConstraints(NSLayoutConstraint.constraints(withVisualFormat: "V:|[tableView]|", options: options, metrics: nil, views: views))
        tableView.layoutIfNeeded()
    }
    
    func recipientsBarReturnButtonClicked(_ recipientsBar: TURecipientsBar) {
        guard let regex = regex, let text = recipientsBar.text else {
            return
        }
        
        let matches = regex.matches(in: text, range: NSRange(location: 0, length: text.count))
        if matches.count > 0 {
            add(email: text, name: nil)
        }
        
        recipientsBar.text = ""
        recipientsBar.resignFirstResponder()
    }
    
    func recipientsDisplayController(_ controller: TURecipientsDisplayController, didRemove recipient: TURecipientProtocol) {
        recipientsUpdated()
        if let recipient = recipient as? MailRecipient {
            recipientsSet.remove(recipient.email)
        }
    }
}

// MARK: - TableView Datasource & Delegate
extension MailComposerViewController: UITableViewDataSource, UITableViewDelegate {
    
    func numberOfSections(in tableView: UITableView) -> Int {
        return model.sections.count
    }
    
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        return model.sections[section].rows.count
    }
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        let item = model.sections[indexPath.section].rows[indexPath.row]
        let cell = tableView.dequeueReusableCell(withIdentifier: R.reuseIdentifier.mailInvoiceClientCell.identifier, for: indexPath)
        item.configure(cell)
        return cell
    }
    
    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        if let row =  model.sections[indexPath.section].rows[indexPath.row] as? TableRow<MailInvoiceClientCell, NoOperationClientAction> {
            add(client: row.item.item)
        }
        bar.text = ""
        bar.resignFirstResponder()
    }
}

// MARK: - Push Notifications
extension MailComposerViewController {
    
    private typealias PushEnableType = () -> Observable<APNState>
    
    /// Does exactly what the title says, checks if push is enabled and presents a dialog
    /// to the user if needed
    ///
    /// - Returns: Observable for when it's done
    fileprivate func checkIfPushNotificationsIsEnabled() -> Observable<Void> {

        if UITestHelper.isUITesting {
            return Observable.just(())
        }
        
        var obs: Observable<APNState> = Observable.empty()
        
        let state = registerPushNotificationModel.pushNotificationsRegistered
        switch state {
        case .accepted:
            return Observable.just(())
        case .denied:
            obs = enablePush(with: registerPushNotificationModel.showSettings)
        case .unknown:
            obs = enablePush(with: registerPushNotificationModel.registerForRemoteNotifications)
        }
        
        return obs.do(onNext: { _ in
            if let token = Messaging.messaging().fcmToken, state == APNState.accepted {
                _ = DeviceRequest.upload(token: token, context: Horreum.instance!.mainContext).take(1).subscribe()
            }
        }).mapToVoid()
    }

    /// Enables Push Notifications, either shows the alert for enabling or redirects the user to the settings of the app
    ///
    /// - Parameter method: which is used for enabling
    /// - Returns: the state after trying to enable it
    private func enablePush(with method: @escaping PushEnableType) -> Observable<APNState> {
        
        return Observable.create({ (observer) -> Disposable in
            
            let alert = UIAlertController(title: R.string.localizable.information(), message: R.string.localizable.pushNotificationExplanationText(), preferredStyle: .alert)
            let cancel = UIAlertAction(title: R.string.localizable.cancel(), style: UIAlertActionStyle.cancel) { _ in
                observer.onNext(APNState.denied)
                observer.onCompleted()
            }
            let open = UIAlertAction(title: R.string.localizable.allow(), style: UIAlertActionStyle.default) { _ in
                _ = method().take(1).subscribe(observer)
            }
            alert.addAction(cancel)
            alert.addAction(open)
            
            if let ctr = UIApplication.shared.topMostViewController() {
                ctr.present(alert, animated: true)
            } else {
                observer.onNext(APNState.denied)
                observer.onCompleted()
            }
            
            return Disposables.create()
        })
    }
}
